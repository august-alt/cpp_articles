[исходник](https://doc.qt.io/qt-6/qttestlib-tutorial2-example.html)
# Глава 2: Тестирование на основе данных

Как создать тест на основе данных

В этой главе мы продемонстрируем как выполнить тест несколько раз с разными наборами данных.

До сих пор мы жестко задавали данные в коде, для тестирования. Если мы добавим больше данных, то это может выглядеть так: 

~~~
QCOMPARE(QString("hello").toUpper(), QString("HELLO"));
QCOMPARE(QString("Hello").toUpper(), QString("HELLO"));
QCOMPARE(QString("HellO").toUpper(), QString("HELLO"));
QCOMPARE(QString("HELLO").toUpper(), QString("HELLO"));
~~~

Для того, чтобы избежать повторения кода, QT тесты поддерживают добавление данных для проведения тестов. Все, что нам надо, это добавить другой приватный слот в наш тестовый класс:

~~~
class TestQString: public QObject
{
    Q_OBJECT

private slots:
    void toUpper_data();
    void toUpper();
};
~~~

Написание функции для добавления данных
***

Функция для добавления данных к тесту носит тоже имя что и тестовая функция с добавлением суффикса _data. Наша функция добавления данных выглядит так:

~~~
void TestQString::toUpper_data()
{
    QTest::addColumn<QString>("string");
    QTest::addColumn<QString>("result");

    QTest::newRow("all lower") << "hello" << "HELLO";
    QTest::newRow("mixed")     << "Hello" << "HELLO";
    QTest::newRow("all upper") << "HELLO" << "HELLO";
}
~~~

Во-первых, мы объявляем два элемента тестовой таблицы, используя функцию QTest::addColumns(): тестовая строка, и ожидаемый результат выполнения QString::toUpper() функции для этой строки.

Затем мы добавляем некоторые данные в таблицу, используя QTest::newRow() функцию. Каждый набор данных станет отдельной строкой в таблице.

QTest::newRow() принимает один аргумент: имя которое будет ассоциировано с набором данных и использовано в журнале тестов для идентификации набора данных. Затем, мы направляем набор данных в новую строку таблицы. Первым - строку для проведения теста, а потом ожидаемый результат применения QString::toUpper() функции к этой строке.

Вы можете представить, что тестовые данные представляют собой двумерную таблицу. В нашем случае, она имееет две колонки, названные string и result, и три строки. Кроме того, с каждой строкой связано имя как индекс, ассоциированный с каждой строкой.

|index|name|string|result|
|----:|--------:|------:|-----:|
|0    |all power|"hello"|HELLO|
|1    |mixed    |"Hello"|HELLO|
|2    |all upper|"HELLO"|HELLO|

Когда данные добавляются в строк, каждый элемент проверяется на соответствие типу столбца. Если проверка не удалась, то тест прерывается.

Переписывание тестовой функции
***

Наша тестовая функция теперь должна быть переписана:

~~~
void TestQString::toUpper()
{
    QFETCH(QString, string);
    QFETCH(QString, result);

    QCOMPARE(string.toUpper(), result);
}
~~~

Функция TestQString::toUpper() теперь будет выполняться три раза, один раз с каждой строкой из тестовой таблицы, которую мы создали и в функции TestQString::toUpper_data().

Сначала, мы получаем два элемента из набора данных с помощью макроса QFETCH(). Макрос QFETCH() принимает два аргумента: тип данных элемента и его имя. Затем мы выполняем проверку с помощью макроса QCOMPARE().

Такой подход позволяет достаточно легко добавлять новые наборы данных для теста без изменения самого теста.

И снова, для того, чтобы наш тест был отдельным выполняемым файлом, нужно добавить строки:

~~~
QTEST_MAIN(TestQString)
~~~

Как и раньше, макрос QTEST_MAIN() разворачивается в простой метод main(), который запускает все тесты, а поскольку и объявление и реализация нашего тестового класса находятся в файле .cpp, нам необходимо включить сгенерированный файл moc, чтобы работала интроспекция Qt.


